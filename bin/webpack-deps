#!/usr/bin/env node

var fs = require('fs');
var path = require('path');
var _ = require('lodash');
var yargs = require('yargs')
              .usage('Usage: \n$0 [stats.json file] --from [array of file names]\n\n or alternatively: \n\n[array of file names] | $0 [stats.json file]')
              .alias('f', 'from')
              .array('f')
              .alias('c', 'count')
              .boolean('c')
              .alias('h', 'help')
              .help();
var argv = yargs.argv;

var webpackDeps = require('../index');

var statsFileName = argv._[0] || 'webpack-stats.json';
var statsFilePath = path.join(process.cwd(), statsFileName);

// why bother with callbacks when you can block?
var stats = JSON.parse(fs.readFileSync(statsFilePath, 'utf8'));

function formatFileNames(files) {
  return files.map(function(file) {
    return './' + path.join('.', file);
  });
}

function writeOut(arr) {
  arr.forEach(function(d) {
    process.stdout.write(d + '\n');
  });
}

function findDeps(filesToCheck) {
  var dependentsMap = webpackDeps.getDependentsMap(stats);
  writeOut(webpackDeps.getAllDependentsForFiles(formatFileNames(filesToCheck), dependentsMap));
}

function outputDependentCount(from) {
  var dependentsMap = webpackDeps.getDependentsMap(stats);
  from = from || Object.keys(dependentsMap);
  writeOut(from.map(function(d) {
    return '' + (dependentsMap[d] ? dependentsMap[d].length : 0) + '\t' +  d;
  }));
}

function output(from) {
  from = formatFileNames(from);

  if (argv.count) {
    outputDependentCount(from);
  } else {
    findDeps(from);
  }
}

if (argv.from) {
  output(argv.from);
} else {
  var input = [];
  var inputCheck;

  process.stdin.setEncoding('utf8');
  process.stdin.on('data', function(data) {
    input = input.concat(data.split('\n'));
  });

  inputCheck = setTimeout(function() {
    process.stdin.pause()
    yargs.parse(['--help']);
  }, 100);

  process.stdin.on('end', function() {
    clearTimeout(inputCheck);

    output(input);
  });
}
